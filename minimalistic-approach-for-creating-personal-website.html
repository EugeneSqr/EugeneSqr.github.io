<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <title>Минималистичный подход к созданию личного сайта</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../css/styles.css" media="screen">
    <script src="../js/core.js"></script>
</head>
<body onload="PR.prettyPrint()">
    <div id="header" class="col-md-12">
        <div class="container">
            <div class="languagebar text-right">
                <a href="/minimalistic-approach-for-creating-personal-website.html" class="flag flag-ru"></a>
                <a href="/en/minimalistic-approach-for-creating-personal-website.html" class="flag flag-us"></a>
            </div>
            <nav class="navbar navbar-default" role="navigation">
                <div class="container-fluid">
                    <div class="navbar-header">
                        <a class="navbar-brand" href="/">
                            <span id="me">Евгений Скурихин</span>
                            <span class="icon-link"></span>
                            <span id="tagline">Простой код, который работает</span>
                        </a>
                    </div>
                    <ul class="nav navbar-nav navbar-right">
                        <li class="nav"><a href="https://github.com/EugeneSqr">github</a></li>
                    </ul>
                </div>
            </nav>
        </div>
    </div>
<section class="container">
<div class="view-frame">
<article id="minimalistic-approach-for-creating-personal-website" class="col-md-9">
<header>
<h2>Минималистичный подход к созданию личного сайта</h2>
<span class="glyphicon glyphicon-time date"></span>
<span class="date">2016-05-27</span>
</header>
<h4 id="">Годы идут</h4>
<p>Модные практики уступают место прагматизму и минимизации затрат на поддержку. Новый опыт заставил меня пересмотреть свое отношение к этому сайту. Основные идеи я решил изложить ниже.</p>
<h4 id="-1">Одностраничный дизайн не нужен</h4>
<p>Главными преимуществами одностраничного подхода являются отзывчивость пользовательского интерфейса и более простое управление состоянием. Если страницы сайта похожи, одностраничное приложение позволяет загрузить шаблон один раз и использовать его повторно.</p>
<p>К основным недостаткам относятся SEO и необходимость дополнительных библиотек для обработки маршрутизации и истории. Если следовать веяниям времени, то скорее всего выбор будет сделан в пользу одного из популярных средств разработки (Angular, Amber, React, Aurelia и так далее).</p>
<p>Для личного сайта отзывчивость интерфейса не нужна, так как взаимодействие с пользователем сведено к минимуму. По той же причине управление состоянием не является проблемой. Доля содержимого сайта на страницах высока, а это значит, что большинство страниц сайта будут сильно различаться.</p>
<p>С другой стороны, рейтинг в поисковых системах имеет первостепенное значение. Заметки пишутся для людей, какой от них толк, если никто не сможет их найти и прочесть? </p>
<p>Современные библиотеки для одностраничных приложений тяжелы, если соотносить их с размером содержимого сайта. </p>
<p>Не последнее значение имеют затраты личного времени на поддержку. Технологии не стоят на месте, приходится за ними следить, даже если в текущий момент фокус направлен не на web.</p>
<h4 id="-2">Серверное приложение и база не нужны</h4>
<p>Серверное приложение необходимо для выполнения бизнес-логики, которую нельзя доверить клиентской части из соображений безопасности или производительности. В типовом личном сайте такая логика отсутствует.</p>
<p>Серверный код должен где-то выполняться, за это нужно платить деньги. Можно это делать бесплатно на <a href="https://heroku.com">heroku</a> или <a href="https://appharbor.com">app harbor</a>, однако процесс будет "засыпать" в моменты простоя, при первом обращении сайт будет "прогреваться" до десяти секунд.</p>
<p>База необходима для хранения содержимого, а также для обработки запросов. Что если для хранения использовать обычную файловую систему, а результат всех возможных запросов распределить по файлам? </p>
<p>Например, список заметок для главной странице можно построить заранее, подтянуть к нему необходимые метаданные (идентификатор заметки, дата создания, заголовок и так далее) и все вместе сохранить в отдельный файл на сервере. Клиенту останется только запросить и обработать этот файл.</p>
<h4 id="-3">Статический сайт</h4>
<p>Вот так и получается статический сайт. Не нужно хранить HTML, простой текст во много раз предпочтительнее, ввиду читабельности. Готовая разметка должна получаться из него автоматизированным преобразованием. Вот основные преимущества такого подхода: </p>
<ul>
<li>текстовые файлы можно редактировать в самом лучшем редакторе – в том, который Вы привыкли использовать каждый день. Скрипты, макросы, подсветка синтаксиса прилагаются. Не нужно ничего дополнительно устанавливать и заново осваивать;</li>
<li>управление содержимым сайта осуществляется средствами операционной системы. Вы просто создаете, переименовываете, удаляете папки и файлы. Снова используются привычные инструменты, ничего не устанавливается дополнительно;</li>
<li>кэширование получившихся страниц "просто работает", обновление кэша происходит "само" при изменении содержимого;</li>
<li>не нужно обновлять свой код под очередное обновление средств разработки;</li>
<li>процедура публикации - простое копирование получившихся после всех преобразований файлов.</li>
</ul>
<h4 id="gulpgrunt">Система сборки или Gulp против Grunt</h4>
<p>Grunt долгое время служил мне верой и правдой, он отлично справляется со своими задачами, так зачем его менять? </p>
<p>Много десятилетий назад умные люди придумали конвейеры (pipes) в Unix и стали использовать их как клей для соединения небольших узкоспециализированных модулей. Решение оказалось очень удачным, оно широко применяется по сей день.</p>
<p>В качестве альтернативы можно где-нибудь сохранять промежуточные результаты работы каждого модуля и использовать их в других модулях. Это менее эффективно, приходится дополнительно следить за очисткой, да и зачем вообще "мусорить"? </p>
<p>Если нужно найти что-то по имени в текущей директории, можно сохранить ее содержимое в файл, затем выполнить поиск по содержимому этого файла и, наконец, удалить его:</p>
<pre class="prettyprint">
ls ~ > contents
grep "text-to-find" contents
rm contents
</pre>
<p>То же самое при помощи конвейера делается так:</p>
<pre class="prettyprint">
ls ~ | grep "text-to-find"
</pre>
<p>Gulp блестяще реализовал эту идею в JavaScript, склонив меня на свою сторону.</p>
<h4 id="-4">Реактивные представления</h4>
<p>Под реактивным представлением нужно понимать такое представление модели, которое обновляется при изменении модели (одностороннее связывание) и обновляет модель при собственном изменении (двустороннее связывание). Библиотеки для построения таких представлений тяжеловесны при всей своей полезности. Например, последняя версия <a href="http://knockoutjs.com">Knockout</a> занимает 25 килобайт. </p>
<p>В случае с личным сайтом, нужно только односторонне связывание, да и то примененное один единственный раз при загрузке страницы. Сервер выдает данные (модель), страница получает их и "надувается" путем создания новых элементов в DOM. </p>
<p>Создавать элементы можно при помощи jQuery (избыточно), либо средствами JavaScript (код быстро разрастается, его становится сложно читать). А что если создавать элементы, используя селекторы CSS? Их синтаксис лаконичен и широко используется, сама <a href="https://github.com/kriszyp/put-selector">библиотека</a> легковесная.</p>
<p>Вот так может выглядеть заполнение списка заметок на главной:</p>
<pre class="prettyprint">
import { getAsync } from "./resource.js"
import { assertArray, assertObject } from "./assert.js"
import put from "put-selector"
import markdown from "showdown"

export class ListViewModel {
    inflate() {
        getAsync("post-headers.json").then(
            posts => {
                assertArray(posts, "posts headers must be an array");

                posts.reverse().forEach(post => {
                    let listElement = document.getElementById("post-listing");
                    assertObject(listElement, "post listing root element does not exist");

                    let postElement = put(listElement, "li");
                    let postHeaderElement = put(postElement, "header");
                    put(
                        postHeaderElement,
                        "a[href='" + post.url + "'] h2",
                        post.title);
                    put(postHeaderElement,
                        "span.glyphicon.glyphicon-time.date");

                    put(postHeaderElement,
                        "span.date",
                        ` ${post.dateCreated}`);
                    put(
                        postElement,
                        "div",
                        { innerHTML: new markdown.Converter().makeHtml(post.header) });
                });
            },
            error => {
                console.log("error getting model", error);
            });
    }
}
</pre>
<p>Данный модуль может быть загружен с главной страницы:</p>
<pre class="prettyprint">
"use strict";
System.import("source/view/js/listViewModel.js").then(function(m) {
    var viewModel = new m.ListViewModel();
    viewModel.inflate();
});
</pre>
<h4 id="jquery">jQuery не нужен</h4>
<p>Приведенный код иллюстрирует еще один принцип - отказ от jQuery ввиду избыточности. Каждая страница моего сайта загружает в среднем 130 килобайт. Если в будущем отбросить поддержку IE 11, значение будет меньше. Последняя на текущий момент версия jQuery занимает 32 килобайта. Лично я не вижу необходимости сходу утяжелять проект на четверть.</p>
<p>Есть мнение, что эти 32 килобайта на самом деле уже есть в кэше Вашего браузера благодаря широкому распространению библиотеки через CDN (Content Delivery Network), то есть на практике ничего грузить не надо. Начните использовать несколько браузеров в приватном режиме, и преимущество кэша улетучится. 32 килобайта - это 32 килобайта, точка.</p>
<h4 id="-5">Размещение сервера</h4>
<p>Статический сайт может размещаться где угодно, любой HTTP сервер способен выдавать файлы. На мой взгляд, оптимальным вариантом здесь является <a href="https://pages.github.com">GitHub pages</a>. Я храню на GitHub свой код уже давно, надежность и доступность сервиса вопросов не вызывают. Процедура обновления сайта - запись изменений в master ветку специального репозитория - легко автоматизируется. Сервис бесплатный, что тоже очень приятно.</p>
<h4 id="-6">Заключение</h4>
<p>Не стоит сходу применять стандартные подходы к построению крупных корпоративных решений к личному сайту. Эта задача намного более простая, открывается возможность для экспериментов. Как известно, совершенство достигается не тогда, когда нечего добавить, а когда нечего убрать.</p>
</article>
<section id="sidebar" class="col-md-3 visible-md visible-lg">
    <h5>Еще заметки</h5>
    <ul id="sidebar-list" class="separated-list">
    </ul>
</section>

<script src="/js/common.js"></script>
<script src="/js/postViewModel.js"></script>
<script>
    "use strict";
    System.import("source/view/js/postViewModel.js").then(function(m) {
        var viewModel = new m.PostViewModel();
        viewModel.inflate();
    });
</script>

</div>
</section>
</body>
</html>
